# Part 2. 데이터베이스 구축
###### 정보처리기사 실기 준비
> 1. 데이터베이스 개념
>> 데이터베이스의 정의
>> 
>> 스키마의 정의
>> 
>> 3계층 스키마 (외부-개념-내부 스키마)
>>
>> 데이터의 독립성
>>
>> DBMS의 기능
>>
>> DBMS의 종류
>> 
> 2. 데이터베이스 설계
>> 데이터베이스 설계 단계 (요구조건 분석 - 개념적 설계 - 논리적 설계 - 물리적 설계 - 구현)
>>
> 3. 데이터 모델링
>> 데이터모델 표시해야 할 요소
>>
> 4. 논리 데이터베이스 설계
>> 데이터베이스 정규화(Normalization)
>>
>> 이상 현상(Anomaly)
>>
>> 함수적 종속(Functional Dependency)
>>
> 5. 물리 데이터베이스 설계
>>
>> 반정규화
>>
>> 데이터베이스 백업 방식
>>
>> 복구 시간 목표 / 복구 시점 목표
>>
>> 데이터베이스 암호화 방식



## 1. 데이터베이스 개념

### 📌 데이터베이스의 정의 (공장통운)
* 공유 데이터(Shared Data) - 여러 응용 프로그램들이 공동으로 사용하는 데이터
* 저장 데이터(Stored Data) - 컴퓨터가 접근 가능한 저장 매체에 저장된 데이터
* 통합 데이터(Integrated Data) - 검색의 효율성을 위해 중복이 최소화된 데이터의 모임
* 운영 데이터(Operational Data) - 조직의 목적을 위해 존재 가치가 확실하고 반드시 필요한 데이터

### 📌 스키마의 정의
* 데이터베이스의 구조와 제약조건에 관해 전반적인명세를 기술한 것.
* 개체(Entity)는 여러 속성(Attribute)의 집합으로 이루어져 있으며, 개체들 사이에는 관계(Relation)가 존재한다.

### 📌 3계층 스키마 (외부-개념-내부)
#### 1. 외부 스키마(External Schema) - 사용자 뷰
* 사용자나 응용 프로그램의 관점에서 데이터베이스의 논리적 구조를 정의한다.
* 전체 데이터베이스의 한 논리적 부분으로 서브스키마라고도 한다.
* 하나의 데이터베이스에는 여러 개의 외부스키마가 존재 가능하다.
* 하나의 외부스키마를 여러 개의 응용프로그램이나 사용자가 공유 가능하다.
* 질의어(SQL)를 이용하거나 C, Java 등 언어를 사용하여 DB에 접근한다.

#### 2. 개념 스키마(Conceptual Schema) - 전체적인 뷰
* 데이터베이스의 전체적인 논리적 구조를 나타내며, 전체 조직의 데이터 요구사항을 종합적으로 반영한다.
* 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로 하나만 존재한다. (일반적으로 하나의 데이터베이스에는 하나의 개념 스키마만 존재)
* 데이터베이스 파일에 저장되는 데이터의 형태를 나타내는 것으로, 단순히 스키마라고 하면 개념 스키마를 의미한다.
* 데이터의 접근 권한, 보안 정책, 무결성 규칙에 대한 명세를 정의한다.

#### 3. 내부 스키마(Internal Schema) - 저장 스키마
* 물리적 저장장치의 입장에서 본 데이터베이스의 구조이다.
* 실제로 데이터베이스에 저장될 레코드의 물리적인 구조를 정의하고, 저장 데이터 항목의 표현방법, 내부 레코드의 물리적 순서 등을 나타낸다.

### 📌 데이터의 독립성
#### 논리적 독립성 
* 개념 스키마가 변경되어도 외부 스키마에는 영향을 미치지 않도록 지원
* 응용 프로그램에 영향을 주지 않고 데이터베이스 논리적 구조를 변경할 수 있는 능력

#### 물리적 독립성
* 내부 스키마가 변경되어도 외부/개념 스키마가 영향을 받지 않도록 지원
* 응용 프로그램이나 데이터베이스의 논리적 구조에 영향을 미치지 않고 데이터의 물리적 구조를 변경할 수 있는 능력

### 📌 DBMS의 기능 (정조제)
* 데이터 정의 - 데이터에 대한 형식, 구조, 제약조건들을 명세하는 기능 -> DDL
* 데이터 조작 - 특정한 데이터를 검색하기 위한 질의, 데이터베이스의 갱신, 보고서 생성 기능 -> DML
* 데이터 제어 - 데이터 무결성(Integrity), 보안(Security) / 권한 (Authority) 검사, 동시성 제어(Concurrency Control) -> DCL

### 📌 DBMS의 종류
1. 계층형(Hierarchical Database)
* 데이터 간의 관계가 트리 형태의 구조
* 데이터를 세그먼트(레코드) 단위로 관리하며 세그먼트 간 계층을 트리구조로 관리
* 구조가 간단하고 구현, 수정, 검색이 쉽지만 부모 자식 간에 N:N(다 대 다) 관계 처리가 불가능하고, 구조 변경이 어려워 잘 사용하지 않음

2. 네트워크형(Network Database)
* 계층형 데이터베이스의 단점을 보완하여 데이터 간 N:N(다 대 다) 구성이 가능한 망형 모델
* 계층 구조에 링크를 추가하여 유연성과 접근성을 높임
* 구조가 복잡해 유지보수가 어려워 잘 사용하지 않음
* CODASYL이 제안한 것으로, CODASYL DBTG모델이라고도 함

3. 관계형(Relational Database)
* 키(Key)와 값(Value)으로 이루어진 데이터들을 행(Row)과 열(Column)로 구성된 테이블 구조로 단순화시킨 모델
* SQL(Structured Query Language)을 사용하여 데이터를 처리

4. 객체 지향형(Object-Oriented Database)
* 객체지향 프로그래밍 개념에 기반하여 만든 데이터베이스 모델
* 정보를 객체의 형태로 표현
* 객체지향 프로그래밍 개념(클래스, 상속 등)을 사용할 수 있다.
* 비정형 데이터들을 데이터베이스화할 수 있도록 하기 위해 만들어진 모델

5. 객체 관계형(Object-Relational Database)
* 관계형 데이터베이스에 객체 지향 개념을 도입하여 만든 데이터베이스 모델
* 객체지향 개념을 지원하는 표준 SQL을 사용할 수 있고, 데이터 타입도 관계형 데이터베이스보다 더 다양하게 추가

6. NoSQL
* Not only SQL로 SQL뿐만 아니라 다양한 특성을 지원한다는 의미
* 데이터 간에 관계를 정의하지 않는 데이터베이스 모델로 기존의 RDBMS의 복잡도와 용량의 한계를 극복하기 위한 목적으로 만들어짐
* 비정형 데이터 처리에 유리하지만 스키마 변경이 불가능해 데이터값에 문제가 발생하면 감지가 어려움

7. NewSQL
* RDBMS의 SQL과 NoSQL의 장점을 결합한 관계형 모델
* 트랜잭션 지원 및 확장성과 고가용성을 모두 만족시키려는 목적에서 만들어진 데이터베이스 모델

---

## 2. 데이터베이스 설계

### 📌 데이터베이스 설계 단계
#### 1. 요구조건 분석
* 데이터베이스의 사용자, 사용목적, 사용범위, 제약조건 등에 대한 내용을 정리하고 명세서를 작성
* 트랜잭션 유형, 트랜잭션 실행빈도와 같은 동적 요구조건 정의

#### 2. 개념적 설계
* 데이터베이스의 개념적 스키마 구성 (E-R 다이어그램)
* 현실세계를 데이터관점으로 추상화 단계
* DBMS에 독립적으로 설계
* 트랜잭션 모델링 및 정의

#### 3. 논리적 설계 
* 관계형 데이터베이스인 경우 이 단계에서 테이블을 설계하는 *정규화* 과정 수행
* 트랜잭션 인터페이스 설계
* 자료를 컴퓨터가 이해할 수 있도록 *목표 DBMS*의 논리적 자료 구조로 변환하는 과정
* 특정 데이터모델(계층형, 관계형, 객체지향형 등)을 적용한 설계
* 데이터베이스의 논리적 스키마 생성

#### 4. 물리적 설계
* 특정 DBMS의 물리적 구조와 내부적인 저장구조, 분산형태, 데이터타입의 특징, 인덱스의 특징 등을 구체화하는 설계단계
* 레코드 집중의 분석 및 설계
* 오브젝트, 접근방법, 트랜잭션분석, 인덱스, 뷰, 데이터베이스 용량설계 등을 수행
* 데이터베이스의 물리적 스키마 생성
* 트랜잭션 세부 설계
* 성능을 위해 파티션, 클러스터링, 인덱스, 뷰 등을 수행. 그러다 안되면 *반정규화* 수행

#### 5. 구현
* 특정 DBMS의 DDL로 기술된 명령문을 컴파일하고, 실행시켜 데이터베이스 스키마 생성

---
## 3. 데이터 모델링
### 📌 데이터모델 표시해야 할 요소
1. 구조(Structure)
* 데이터베이스에 표현될 대상으로서의 개체 타입과 개체 타입들 간의 관계
* 데이터 구조 및 정적 성질

2. 연산(Operation)
* 데이터베이스에 저장될 실제 데이터를 처리하는 방법

3. 제약조건(Constraint)
* 저장될 수 있는 데이터의 논리적인 제약조건

---

## 4. 논리 데이터베이스 설계
### 📌 데이터베이스 정규화(Normalization)
#### 정규화의 개념
* 관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화
* 중복된 데이터를 허용하지 않음으로써 무결성(Integrity)을 유지할 수 있으며, DB의 저장 용량도 줄일 수 있다.

#### 정규화의 목적
* 데이터의 중복을 최소화
* 정보의 무손실 - 정보가 사라지지 않아야 함
* 독립적인 관계는 별개의 릴레이션으로 표현
* 검색 용이성 증가
* 이상 현상 최소화

#### 정규화의 장/단점 
* 장점
  * 데이터 중복의 최소화
  * 저장 공간의 효율적 사용
  * 릴레이션에서 발생 가능한 이상 현상 제거
* 단점
  * 처리 명령의 복잡
  * 실행 속도 저하
  * 분리된 두 릴레이션 간 참조 무결성 유지를 위한 노력 필요
  * 분리된 여러 개의 테이블에서 정보를 취합하기 위한 JOIN 연산 필요

### 📌 이상 현상(Anomaly)
* *데이터 중복으로 인해* 릴레이션 조작 시 예상하지 못한 곤란한 현상이 발생
* 이상은 속성들 간에 존재하는 여러 종류의 종속 관계를 하나의 릴레이션에 표현할 때 발생
#### 이상의 종류
1. 삽입 이상 : 데이터를 삽입할 때 <ins>*불필요한 데이터*</ins> 가 함께 삽입되는 현상
2. 삭제 이상 : 한 튜플을 삭제할 때 <ins>*연쇄 삭제 현상*</ins> 으로 인해 정보 손실
3. 갱신 이상 : 튜플의 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 <ins>*정보에 모순*</ins> 이 생기는 현상

### 📌 함수적 종속(Functional Dependency)

#### 함수적 종속 개념
* 어떤 릴레이션 R의 X와 Y를 각각 속성의 부분집합이라고 가정했을 때, X의 값을 알면 Y의 값을 바로 식별할 수 있고, X의 값에 Y의 값이 달라질 때, Y는 X에 함수적 종속이라고 한다.
* 이를 기호로 표현하면 X -> Y

#### 함수적 종속 관계
1. 완전 함수적 종속 (Full Functional Dependency)
* 종속자가 기본키에만 종속되며, 기본키가 여러 속성으로 구성되어 있을 때, 기본키를 구성하는 모든 속성이 포함된 기본키의 부분집합에 종속된 경우.

2. 부분 함수적 종속 (Partial Functional Dependency)
* 기본키가 여러 속성으로 구성되어 있을 때, 기본키를 구성하는 속성 중 일부만 종속되는 경우.

ex)
|회원번호|주문번호|물건명|이름|
|:-----:|:-----:|:-----:|:-----:|
|a001|n001|충전기|김유신|
|a002|n002|티슈|김명원|
|a003|n003|물컵|이우재|
|a004|n004|이어폰|이다은|

* 위의 릴레이션에서 물건명은 기본키(회원번호+주문번호)에 종속적이지만, 이름은 회원번호에만 종속된다. 이때, 부분 함수적 종속이 발생한다.
* 이름은 회원번호에만 종속되어 **부분 함수 종속**, 물건명은 기본키에 종속되어 **완전 함수 종속**.

3. 이행적 함수 종속 (Transitive Functional Dependency)
* X -> Y, Y -> Z 이러한 종속 관계가 있을 경우, X -> Z 가 성립되는 경우.

ex)
|회원번호(PK)|주문번호|이름|
|:-----:|:-----:|:-----:|
|a001|n001|김유신|
|a002|n002|김명원|
|a003|n003|이우재|
|a004|n004|이다은|

* 위의 릴레이션에서 회원번호를 알면 주문번호를 알 수 있고, 주문번호를 알면 이름을 알 수 있다. 

### 📌 정규화 과정

|정규화 과정| 만족 조건 |
|:-----:|:-----:|
|비정규 릴레이션||
|⬇️|도메인이 원자값|
|1NF||
|⬇️|부분 함수적 종속 제거|
|2NF||
|⬇️|이행적 함수 종속 제거|
|3NF||
|⬇️|결정자이면서 후보키가 아닌 것 제거|
|BCNF||
|⬇️|다치 종속 제거|
|4NF||
|⬇️|조인 종속성 이용|
|5NF||

* 제 1정규형(1NF)
  * 만족 조건: 어떤 릴레이션에 속한 모든 도메인이 원자값만으로 되어 있다.
* 제 2정규형(2NF)
  * 부분 함수적 종속을 모두 제거하여 완전 함수적 종속으로 만든다.
* 제 3정규형(3NF)
  * 이행적 함수 종속을 없앤다.
* 보이스/코드(BCNF) 정규형
  * 결정자 중 후보키가 아닌 것들을 제거
* 제 4정규형(4NF)
  * 다치 종속을 제거
* 제 5정규형(5NF)
  * 조인 종속 이용 
   
--- 
## 5. 물리 데이터베이스 설계
### 📌 반정규화
#### 반정규화의 개념 
* 데이터베이스 설계에서 정규화를 거친 후, <ins>**성능 향상**</ins>이나 <ins>**개발 및 운영의 편의성**</ins>을 위해 의도적으로 중복을 허용하거나 데이터를 재구성하는 기법.
* 정규화로 인한 여러 테이블의 조인이 성능 저하를 일으킬 때, 반정규화는 이를 개선하기 위해 사용된다.

#### 반정규화 시 고려사항
* 데이터 중복이 발생하여 데이터 수정 시 무결성이 깨질 수 있다.
* 읽기 속도는 향상되지만, 삽입/수정/삭제 속도는 느려질 수 있다.
* 저장 공간의 효율성이 떨어진다.
* 테이블이 크고 복잡해져 유지보수가 어렵다.
* 반정규화를 결정하기 전에 데이터의 일관성과 무결성을 유지할 것인지, 아니면 데이터베이스의 성능을 우선할 것인지 결정해야 한다.

### 📌 데이터베이스 백업
#### 백업 방식
1. 전체 백업(Full Backup)
* 선택된 폴더의 Data를 모두 백업하는 방식

2. 증분 백업(Incremental Backup)
* Full Backup 이후 <ins>변경/추가된 Data만 백업하는 방식</ins>

3. 차등 백업(Differential Backup)
* Full Backup 이후 <ins>변경/추가된 Data를 모두 포함하여 백업</ins> (최초 Full Backup을 제외한 모든 변경/추가된 Data를 매번 백업)

4. 실시간 백업(RealTime Backup)
* 즉각적으로 모든 변경사항을 분리된 스토리지 디바이스에 복사

5. 트랜잭션 로그 백업(Transaction Log Backup)
* 데이터베이스에서 실행되는 모든 SQL문을 기록한 로그 (SELECT를 제외한 나머지)
* REDO(다시 실행), UNDO(원상태로 복구)로 복원
* CHECK POINT : 설정한 지점 이전까지는 트랜잭션이 성공적으로 수행이 되어 Disk에 확실히 저장된 상태

6. 합성 백업
* <ins>기존의 전체 백업본과 여러 개의 증분 백업을 합하여</ins> 새로운 전체 백업을 만드는 작업

### 📌 복구 시간 목표 / 복구 시점 목표
#### 복구 시간 목표(RTO)
* 서비스를 사용할 수 없는 상태로 <ins>**허용되는 기간**</ins>

#### 복구 시점 목표(RPO)
* 마지막 복구 시점과 서비스 중단 시점 사이에 <ins>**허용되는 데이터 손실량**</ins>

### 📌 데이터베이스 암호화 방식

1. **API 방식(중요)**
* 어플리케이션 데이터의 암/복호화를 수행

2. **Plug-in 방식(중요)**
* 데이터베이스 서버에 제품을 설치 -> 암/복호화 수행

3. **TDE(Transparent Data Encryption) 방식(중요)**
* DB 내부에서 암/복호화 처리를 하는 방식
* DBMS에 내장 또는 옵션으로 제공되는 암호화 기능을 이용하는 방식

4. 파일암호화 방식
* 데이터 뿐만 아니라 비정형 데이터 암호화 적용가능

5. 하드웨어 방식
* 별도의 하드웨어 장비를 외부에 설치


















